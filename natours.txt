//***********************************************************************************//
//**********************************************************************************//
1-    Users -----------------------> Reviews: (Parent Referencing. 1 to many Relationship between Users and Reviews.)
        1 to many relationship in between them.




2-    Tours ---------------------> Reviews: (Parent Referencing). 



3-    Tours <--------------------> Locations: Few to Few Relationship (A Version of Many to Many Relationship).
                                    Location inside tours and tours inside locatins. . . 



4-    Tours <---------------------> Users: (It is a few to few relationship.)
                                    Because: 1 tours can have few Tour Guides.
                                    1 Guide can be guiding few tours. (Reference or Embed can be used this case using mongoose.)



5-   Tours ------------------------> Bookings: 1 tour can have many bookings.



6-   Users ------------------------> Bookings: 1 user can have many bookings.




Lecture 150:

--GeoSpatial Data is what mongo db supports out of the box.
--It is supported by MongoDB out of the box.
--Location will be written in the tour model.
--We, in GeoJSON, first will write longitudes and later latitudes. [Number: Longitude, Number: Latitude];
--Start location is just an object now, but to create a document out inside a doc, it needs to be an array.
--Now the Jonas will delete the dev datas, and then import the latest data.

LECTURE: 151
--we are gonna embed user document into the tour document.
--When creating the tour document, the user will simply put the array of user ids.
--



 LECTURE: 152:
-- Now that we knew the drawbacks of embeeding, now we will reference the tour
 guides into the tour documents.
--THE MAIN CONCERN: Tours and Users will remain as completely separate entities in our DBs.
--We are gonna learn about REFERENCING in MONGOOSE actually. 
--We are gonna now make it as type:guides:[type: mongoose.Schema.ObjectId];
--We are gonna make it as an array now (to treat it as a subdoc.);
--Now we will place user object id inside of an array.
-- like: ["fadsfadsf", "423sgfafdgad"];
--(Not done: Jonas making the array of uses and posting tours with references
        users and watching it in the compass).

LECTURE: 153:
--              populating the users.
--Since in tours, we wanted to populate Users, we  make a reference to it and then:
query.populate("users");
--watched upto (3:14 mins.)
--Now Jonas wanna push the query.populate("fieldName") thing into a query middleware.
--Because every single time otherwise we shall have to write .populate("field"),
        and also -_V and -_passwordChanged at to not show minus fields if we're only using populates.

        and also update everything in all routes for this effect to reflect
        everywhere.
        --SO HE JUS THAS SETUP --QUERY MIDDLEWARES -- THAT'S ABOUT IT. 


LECTURE NUMBER: 154

//We want a review, rating and created at, and we would also want a reference to the tour that this review belongs 
to and also the user who wrote this review.  Basucally 2 parent references in here.
--we made a reviewSchema and then we linked our reviews with user and tour. Then we used virtuals: true and 
        tovirtuals: true and we also formed some of key value pairs inside of the reviewModel.

LECTURE NUMBER: 155
--We created the review contreoller, and  wrote a review by signing up and logging in one user and using 
his _id with tour's _id. Now we will populate in lecture: 156.

LECTURE NUMBER: 156
--This time we are gonna populate reviews both by tour data and the user data. 
--We will chain populate method twice.
--2 populates will query db twice.
--took 23 mss my case for 2 db operations.
--Completed the population
--BUG (series of inclusions and exclusion error for --durationWeeks-- for some reason.);

LECTURE NUMBERE 157
--There is a detailed explaination in the video itself, on what needs to be done you know.
--There is a convention for virtual populate now.
--Without  actually persisting it into the DB, we store the array of IDs of reviews in tours collection.

LECTURE NUMBER 158
--In the real world, the user id should come from the currently logged in user.
--We would wanna make a request for the post, reviews,
--we will follow the pattern for: /tour/tourObjectId123/reviews/reviewsObjectId (POST/GET REQUESTS).
--we are now gonna implement the nested route as shown as above.
--we will now implement it right away starting from the tour routes.
-- 

LECTURE NUMBER 159
--In here now we are gonna implement the nested routes in express.
--In 158, what we did is we created a route the way: (POST): tours/tourId/reviews.
--Here we gave tourId in params, used the tourId and then imported the reviewController in tourRouter.
--We then created a review out of tourId and UserId.
--Basically in tour router, we had to import the review controller.
--Now one thing to remember, we can create reviews in 2 ways: Being on Review Router, or by being on tour router.
--We will have duplicate codes, if in case we wanna change anything.
--We are now gonna learn about MERGE PARAMS in Express.
--For the separation of concerns, we will now remove the piece of code that creates reviews from the 
 tourRouter.
--So this way --> import statement of reviewController <-- too is unnecessary.
--Now Jonas Imports the reviewRouter inside of the tourRouter to connect between 2 routers (not controllers.)
--BASICALLY FIRST EVER USE OF (ROUTER.USE('/:tourId/reviews', reviewRouter));
--Since now we are redirected to the reviewRouter, reviewRouter will nowhere know about the tourId when referred.
--We will now incoorporate mergeParams.
--We will now in --reviewRouter do: const router = express.Router({mergeParams: true});

                WhAt DiD nOt WoRk TiLl NoW:
a) Reviews: -> always [] after successfully creating reviwes. (skipped as it took lots of time, will come back later.)

LECTURE NUMBER 160
--ADDING A NESTED GET ENDPOINT --
--ADDED

LECTURE NUMBER 161
--we added up some factory functions for delete. . . 
--past 3 mins left to watch.
--Delets a user too (of course)

LECTURE NUMBER 162
--Creating a factory function for -updating- and -deleting-
--Update: The patch functionality have been embedded in all the controllers, -review, tour and user controller.
-- Implemented Update:
--Implementing Create Handler (testing left):
--slightly confused on implementation for creation of reviews as reviews are created in tour via user.
--In creation for reviews, jonas makes up a new middleware function and he will inject
  that middleware function into the reviewrouter, that will possibly remove the hurdle of checking up of
  the req.body.user and req.body.tourId are either non existent, if not existent for sure
  then, that middleware fn would set it in the body for creation of reviews.
--Required checking the valid Object IDs and all in my case.
--checking in postman is left. (***********POSTMAN THINGS ARE STILL LEFT TO BE DONE ***********)
--

LECTURE NUMBER 163
--Implementing the getOne router handler.
--Instead for us for having just getting a data, we sometimes have a populate options.
--const doc  = await Model.findById(req.params.id).populate('reviews');
--All completed for get One


LECTURE NUMBER 164
--adding a /me endpoiont.
--for a /me endpoint, we will need: we will need to watch a id from the req.user;
--Here we will fake it as if id is coming in request params. 
--Other implementation would be similar to getting a user.
--Here what we did was we injected a middleware before the /specificUserId 
  middleware. And if a user visits /me then, we will programatically put the UserId
  in the params of the logged in user. and boom. It works.

LECTURE NUMBER 165
--Here we will add up the missing authorisation and authentication for any user.
--It is done in Router Basically.
--Jonas Protects some of routes using ROuter.use() method of express.
--Configures RBACs on some of routes on 3 different resources.
--Chapter ends here.

LECTURE NUMBER 166
--We basically imported some of resources into our DB from the file system.
--Imported tours, reviews and users resources.

LECTURE NUMBER 167
--We are now improving the read preformances of the Database with indexes.
--Will do create some Indexes later.
--(❌❌)

LECTURE NUMBER 168
--Removing the constant queries of the related data sets.
--When a review will be created, we will find the way to update tour.
--We will be able to show up number of ratings and average of all the ratings.
--We never ever calculated average ratings quite before, Now that we will calculate it when a review is created or deleted.
--Using reviewModel, we create a function in review model, and using the fn, we will calculate the average of the tours there.
-- The function will at the end update the tour document too.
--We will make a  middleware that will keep track of all the documents.
--


LECTURE NUMBER 169
--(findByIdAndUpdate & findByIdAndDelete), Now we are gonna update the reviews upon update and delete.
--Fragments of documentsa are obtained by Find+Update or Find+Delete methods, so we won't be able to run the 
  ReviewCalculation method as above.
-- Testing is left for this one - whether our implementation of handling the ratingsAverage
   would work or not. (❌❌)
--(Did not work on update and delete.);
--Need to rethink again.

LECTURE NUMBER 170
--We are gonna use a simple trick to  let users not write more than one review for each tour.
--Each User can review one tour and that too only once.
--Since the new objectId made by combination of user and posts have been made unique.
--(❌❌)

LECTURE NUMBER 171
--We are gonna learn about geospatial queries.
--Helps users search for tours in a specific points.
--Distance would be of any miles say 250 mi.
--I can being in Nepal, search for tours based within Nepal.
--used some of geospatial queries now.
--will use somewhere or sometime.
--used $geoWithin and $centerSphere mongo operators now.
--discovered Bunch others in their site.

LECTURE NUMBER 172
--Here we will discover about the distances between start location and the point where tour is located.
--We will use a $geoNear aggregation.
--This requires one of the key to be indexed for using geoNear.
--We index: startlocation:'2dSphere'. It is mandatory.
--Implemented totally.



LECTURE NUMBER 173
--Creating the API Documentation for our APIs.
--We will now manage the passwords in a variables. (--More to watch later--).
--More to be done later.

//*********************SERVER SIDE RENDERING ********************************//
//**************************************************************************//

LECTURE NUMBER 175
--We are now gonna implement the server side rendering in our project.
--We can now log in and sign up in here.
--We can see all the reviews of the users and we can also open up the personal user account.
--We can also check all the bookings of the user.
--We will implement the maps into our project too.


LECTURE NUMBER 176
--This deals about setting up the pug templates and working with it.
--We can easily fill out the template and fill up the data using pug.
--There are couple of other templating engines too available like handlebars or ejs.
--Pugs are also called Views in Express because they are views in MVC Architecture.
--Now we will create up a views folder.
--Now we set view engiene to -pug and so on and so forth.
--We now have created everything for our pug things.
--Now inside pug, we are gonna create -base.pug & then check if it will work. . . 
--

LECTURE NUMBER 177
--Now we are gonna implement a pug in our code.
--The variables that we will pass inside the pug's data as: .render('base', {key:value //This is called locals});
--To show locals we follow the syntax: p1= key; value of the key will be rendered automatically.
--Each assest confirms it's own HTTP request.
--so in favicon, there's img/favicon.png, so how does it work?
--It works by It's own GET request being fired.
--Now we're gonna see how we can send data to the pug templates.
--We can create comments now. . . And the thing is that we can create 2 kinds of comments. 
-- We can embed JS in our code:   Eg: h2= message.toUpperCase();
--Unbuffered code are code that's not gonna add anything to the output.
        
        Eg: -const x = 9;
             h2 = 2 * x;

             p This is just some text.
--We did some computations. We will now convert our Starter HTML file into pug template.



LECTURE NUMBER 178
-- Including the file i.e one template to an another template now.
--done

LECTURE NUMBER 179
--This was all about including the files into the main pug file.
--Syntax: include pugFileName.pug

LECTURE NUMBER 180:
--This lecture is all about using -extends-. Using which we can use the same base layout for all the pages.
--We can extend one pug to an another Can be applied to every single page we can render.
--we made a overview page render route.
--We would also want a route to /tour, so we made it.
--Base template is the parent template and this process is also called extending.
--Now in the overview page, it will extend the base template.
--Understood the differences betweeen extends and includes.
--The base template if is extended on the child template, then parent bases' 


LECTURE NUMBER 181
--Just with the resources, we are gonna create controller for the views.
--181 has come to an end with me building some routes for our views.

LECTURE NUMBER 182
--Now we're building the tours overview page.
--we made upto showing up 9 tours but data shown are not dymamic even now. (NOT DONE IN THE PRACTICE)

LECTURE NUMBER 183
--Here now we are going to basically fill the actual cards with the actual data.
--if in tours we are getting data then we will loop tours and for every tour, we show tour's properties in each cards.
--Jonas now fills up different data into the tour template.
--The example includes: Tour length, tour summary, tour description and all that.
--Now goes start dates. We do: tours.startDaates
--Now we will add relative URLs.
--We added a '|' or 'pipeline' to make it such tha we will get an empty space like as of using <br>
--W


LECTURE  NUMBER 184 
--We are gonna build up a TOUR DETAIL Page.
--We are just gonna leave the map for next lecture. But for now we will work upto Showing up reviews.
--For showing indivudual tours, we shall need to show reviews + tour guides +  
--Render templates using the data from step 01 again.
--We will search the tours with the help of slug. . 
--We should:
        1- Find the dedicated tour.
        2-Populate the tour data with Reviews.
        3-Respond the user with necessary template.

--We have already made the PUG template already.
--Jonas also made the Indivudual tour overview page.
--Now we will get some visually appealing website.
--Now we are gonna look about next pug fetature called: PUG MIXINS.
--For this, we will have to make a preprocessor box.
--We write mixin for this reason, and then write the name of the mixin.
--Jonas makes a preprocessor like PUG MIXIN where he can pass in: 1-Label, 2-Text, and 3-Icon.
--Usage:
        +mixinName(...args);
        Mixin is like a function.

--Similarly the part 01 of the tour completion portion has now come into an end.

LECTURE NUMBER 185
--Building the Tour Detail Page.
--Now we are looping for all the tour guides data from the DB  and then we are basically showing it in our page.
--We will incoorporate each loop in the array.
--We will use:
        each guides in tour.guides.
--Now we are gonna write a role of the user too.
--Since in DB we saved roles as lead-guide and tour-guide and all, but don't wanna show up "-",
  We shall incoorporate --conditionals-- in pug template.
--We will some Unbuffered code and using vanilla js, remove the "-" from the mid roles.
--Or Do anything similar.
--Now for the description box, In DB, we are saving one paragraph for description, crux is we are using \n to distinguish new lines and show up 
  the new line.
  
--Coming onto reviews now, Jonas populates the review.
--Time to show up  stars now for the ratings we have.
--Applies logic to apply for stars in the reviews field.
--Now We gotta go to the "/" page.
--We can also create a separate file for mixins. Jonas calls it as __reviewCard.pug.
--We will write: __reviewCard.pug and then where we should use it: we do: include __reviewCard.pug.
--We will also change the call to action field now. 
--Jonas will now maintain the --call to action-- Now. And then:  Now the page is completed now.


LECTURE NUMBER 186:
--We are now gonna integrate --mapbox-- in our project.
--The mapbox library now works in the  front end.
--We will write some javascript in the client side, and then: we are gonna integrate it.
--We say -block head.
--Jonas basically extracts out the locations from the server and puts the array of lcoations, converting them into strings into locations variable.
--Now to avail it in JS file, it is done this way: JSON.parse(converted String);


LECTURE NUMBER 187
--Integrating the mapbox now in our project.
--Make an account on the mapbox and then: We are gonna itegrate the mapbox cdn into the page.
--We are gonna incoorporate the append head technique now.
--We are gonna put up the link: using block append head technique.
--In mapbox.js file, We are gonna append the access token there.mapboxgl.accessToken.
--var map = new mapboxgl.Map({
                                container: 'map' /*will put map on the id of map*/,
                                style:'mapbox://styles/mapbox/streets-v11',
                                center:[longitude, latitude] //Focuses the map on this center,
                                zoom:4,
                                interractive:true, //Boolean True or False,
                                scrollZoom:false,
                                clickTolerance: false //Boolean
                             });

--Create a mapbox token now.f
--It loads the default map already.
--Go to design studio in mapbox now.
--Jonas now chooses the light map. Chooses the styles and then clicks on -use-
--Now we are gonna get our access URL and style URL now.
--Put it in the javascript code.
--We can basically now zoom in, zoom out and basically do anything we want.
--We can pin a centered coordinates, but by the way the using bound coordinates would be beneficial for array of coordinates,
        basically we wanna show up map, showing all the available geolocation points.

-- const bounds = new mapboxgl.LngLatBounds     ({
                                                });
--To log locations, we shall need markers.

--                              locations.forEach(loc=>{
                                        document.createElement('div');
                                        el.className = 'marker',
                                        new mapBoxGl.Marker(
                                                {
                                                        element: el,
                                                        anchor: 'bottom', //places the bottom part of the marker into the exact GPS Coordinates.
                                                }
                                        )
                                        }).setLngLat(loc.coordinates).addTo(map);

                                        new mapboxgl.popup({offset:30}).setLngLat(loc.coordinates).setHTML(`<p>Day ${loc.day}: ${loc.description} </p>`).addTo(map);

                                        bounds.extend(loc.coordinates
                                        ); //Pass each of locations into  bounds.extend(indivudualLocation);

--map.fitBounds(bounds,
                                                                          {
                                                                             top:200,
                                                                             bottom:200,
                                                                             left:100,
                                                                             right:100
                                                                           }); //Adds the padding of 50px to show all the pinned points.


LECTURE NUMBER 188
--We are now gonna add up the login screen to make sure that the user can now log in.
--We are now gonna add the '/login' route handler which gives out HTML to us that shows us up the login screen.
--We will do it in the views folder.
--exports.getLoginForm = (req,res)=>{ res.status(200).render('login') };
--call it login.pug
--In login.pug ---> extends base;
--block content
--Let's go onto our login router now. 
--Sign in handler is made.
--Now we are going to prepare the sign up page. (SIGN UP WAS GONNA BE AS LONG AS LOGGING IN.);
--Jonas has made up a CSS file that includes the validation logic for the form.
--
--

LECTURE NUMBER 189
--Using our login API to actually log in the users.
--We will incoorporate the cookie thingy too to the user to check user sessions.
--We will be working on the client side JS code then.
--We created the -login.js- file inside of the public > js > login.JS

--document.querySelector('.form').addEventListener('submit', e =>{
                                                                 e.preventDefault();
                                                                 const email = email-value-from-email-element
                                                                 const password = password-value-from-pswd-element
                                                                 })

--We added the login.js file inside the pug template of the login.
--We showed the password and email in the console. (Just for testing);
--We are going to use axios to make a HTTP requests right from the next lecture.
-- <script src=" https://cdn.jsdelivr.net/npm/axios@1.11.0/dist/axios.min.js "></script>
-- It exposes the  axios object into the global scpope that we can use it.
-- const res = await axios({
                method: 'POST',
                url   : '',
                data: {//json can be sent in here with the help of Axios.}
        })
--Axios triggers an error if server responds any non 2xx (Other than status not starting with 2) status codes to us.
--We made a try and catch block to incoorporate the login handler.
--In case of errors, axios puts error inside ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~errObject.response.data;
--Because the browser will use the cookie, We have to install other package inside of our backend called cookieparser.
--const cookieParser = require('cookie-parser');
--Subscequently, We inject the middleware exposed by cookie-parser globally to all the requests using  express' middleware: app.use('cookieParser');
--app.use((req,res,next)=>{

                        });
--Now we are going to watch the cookies inside of the backend using req.cookies. 
--this logs cookies to us. (as object. . {jwt: jwtData});
--Now Jonas imports the auth controller in the views. 
--And then: authController.procect is injected inside the views routes.
--Jonas deletes the cookies from the front end, and this logs out the user.
--After logging in, we will get our JWT, which we will store again in the req.cookies. . .
  and everytime server gets the JWT, it authenticates the user, then gives or revokes an access to certain routes.
--When the user is logged in, we do not wanna show the login and signup thingy on the top of the screen, so we will basically remove it in the next lecture.
--On coming lectures, we will also incoorporate popups for displaying success or errors.
--

LECTURE NUMBER 190
--This is the part 02 of implementing the login functionality.
--We are going to conditionally render the login and signup block watching if a user is logged in or not.
--We are now going to make a new middleware that sees if a user is logged in or not for like all the routes and show or hide the login/register heading in the navbar.
-isLoggedIn middleware will take care of that.
--It will only check if a JWT Exists and it resolves to a user that exists in DB and user has not changed the password, returns next(); immediately.
--We will use res.locals.user, then inside of a template, there will be a user.
--res.locals.user = currentUser will hold the local variables needed for the user. Then we will call next();

--LOGIC OF THE MIDDLEWARE:
                        a- If No JWT in cookies: return next();
                        b- If Password was changed after JWT was issued,  return next();
                        c- Otherwise, assign res.locals.user  = currentUser and return next();
                        This way if locals is having user object inside of it, then the user is logged in, else user is not logged in.
--By using the Locals, we are determining if we should should show up a login/register or any other screens than that.


LECTURE NUMBER 191

--Let's now finish up the logging functionality by now.
--Jonas creats alerts.js
--Also talks about creating the bundlers like webpack.
--We installed a package called: parcel bundler and wrote the entry js file + output location + output file name in the script in package.json.
--We minified one of JS file we had.
--Jonas imports the login handlers in login. . .
--Jonas works onto creating the access tokens now. . . 
--Jonas now appended mapbox script tag as is in the html itself because  using it with @babel thing did not work out.
-- Jonas creats an alert window and then he basically will remove and show all the alerts.
--catch(err){showAlert('err.response.data.message')};
--Login and alert functionality have been successfully added up.
--Logging out functionality is for the next lecture now.

LECTURE NUMBER 192 
--Now we are going to log out the Users from the system.
--Since we are using httpOnly:true key and value. This does not allow us to modify/avail the cookies data in the frontend. 
  So, we cannot do anything at all.
--So, to log the users out, we should make a route, that sends a null value of the cookie's key to us.
--Jonas makes a Route in the authController now in the name  of logout.
   res.cookie(exactNamedKeyThatOfCookie: "You are now logged out of the system", {
                                                                                expires: Date.now()+10*1000,
                                                                                httpOnly: true
                                                                                 });
--Now Jonas works on login.js file and makes a function to show up the alerts when user gets logged out of the system.The 
  function will basically do a a GET request to the server and in case of error shows the error in the UI.
  And that's about it.In case of succes, Jonas does location.reload(true) in the system for Hard reload, (The reload without using the cache.);

--CatchAsync handler will throw up an error to  global error handling middleware.
--Jonas removes the catchsync handler basically from the logout controller.
--We now have successfully  logged out user from our website. 

--NEED TO REWATCH AGAIN...

LECTURE NUMBER 193
--Jonas goes to forest-hikerrr tour which does not even exist.
--We will basically fix this thing now.
--In viewsController.js, Jonas adds up some code inside viewsController, where if in case no tours are found, he throws new AppError object to the user.'
--In errorController.js, Jonas basically adds some lines of code that: 
--In sendErrorDev: (err, msg) => if in case the req.originalUrl starts with "/api", jonas renders the error page.
--In sendErrorProd: (err, msg)=>  res.status.json({error})
--Jonas makes in a error template inside views.js.
--Jonas logs the error message for views pages in UI; For that we will extend our base template and: in the block content, we will insert main
--Jonas shows some generic error message to the User.
--We now have error handling Strategy for views in Production and in Development.


LECTURE NUMBER 194
--Now we are going to build the user account with ('/me') middleware.
--We already have userAccount template there in account template.js.
--We make mixins and all that and all those.
--Using mixins, we will basically make some repetitive blocks, non repetitive.
--Logout route: working.
--Admin panel working.



LECTURE NUMBER 195
--We will now allow the user to update first name, last name and photo (next lecture);
--Personally we can do it in 2 ways: a- Use forms to send first name and last name with form data. (Disadvantage: Requires page reload + different routes);
--In order to submit the form automatically, we need to specify action in form called action = submit-user-data and method = "POST";
--If we click on submit on the form, then it is basically gonna submit the form on the specified endpoint.
--We need to specify the name attributes in the form key fields: name=email as attributes to the input elements inside the form.
--Now implementing the controller now. 
--In the viewsController, we implement this route.
--router.post("submit-user-data", we are gonna get 2 keys: name + email there.);
--Now, need to use a middleware from express called: express.urlEncoded({extended: true}, limit: '10kb');
--Use findByIdAndUpdate and then update the data in the Database. 
 

LECTURE NUMBER 196 
--We will now use our API to update user in the backend.
--The function name is updateData now. 
--Call the function from the index.js.
--const res = await axios({method: PATCH, url: xyz, data: {},  headers: {}, timeout: 5000 });
--Import the function in index.html;

--WATCHED UPTO 10 MINUTES.  
--While submitting the form, get the: email and name of the user then call updateData function.
--updateData will create a post request and if data is updated, then: it will get the data and store it in the variable,
--If res.data.status is success then: it shows the success in the UI, else it will fail.


LECTURE NUMBER 197
--In this lecture, we will change the password of the User.
--Jonas passes in data and then types: DATA + TYPES:
--Data that we are sending here is just a data object.
--We have already made the /updateMyPassword handler in the postman. This basically requires password passwordCurrent and passwordConfirm.
--Jonas has already made the updateSettings handler, and he sees the types if password is being wanted to be changed.
--If change type is password, then the hit url is different, else it is totally different.
--In the UI too, It will show as being updated.
--So if the  password will been updated successfully,it shows updated, else shows rejected.
--Same goes for changing the password, we will extend the same of updateSettings function to make it working.
--We write a-password b-currentPassword  c-passwordConfirm and then send a post hook.
--After the data comes from the server, we empty the form datas.
--We will create email templates, we will create file uploads the next.


LECTURE NUMBER 198
--We are now uploading images using Multer package.
--It is used to handle the multipart form data.
--Multer is basically a middleware for multipart form data.



LECTURE NUMBER 200
--Allow only images to be uploaded to the server.
--Giving images a better file name.
--setting up multer is done finally and then: 
--we export a middleware upload.single('photo');
-- const multerStorage = multer.diskStorage({
        destination:(req, res, cb) =>{

        },
        fileName: (req, res, cb) => {
                const ext = 
        }
})

const fileFilter = (req, file, cb) =>{
                if(file.mimeType.startsWith('image')){
                        cb(null, true);
                }
                else{
                        new AppError(('only image files are allowed'), false);
                        //Basically we are creating an error in else section. 
                        //
                }
};
--Now we are doing some more testings on the multer middleware.
--

--This is what we will export so that the file shall be uploaded in a designated location.
--

const multer = multer({storage: storage, fileFilter: fileFilter});

exports.uploadUserPhoto = 

--Jonas selects some other images which is not an image, it does not upload it, and throws an App Error's Error Object to user.


LECTURE NUMBER 201
--Now we are saving the Image name to the User Database, so as to avail  the user accesses their corresponding images.
-- After the filteredObject, the Jonas does this: 
--We will create a filtered request object and for the filtered request  object: we will add a photo key with the photo name there and update the database.
--And for default image, we basically update the model and put default image link there.

LECTURE NUMBER 202
--Now we're gonna learn about image processing.
--We will save files into the memory first with approach: multer.memoryStorage();
--
-- exports.resizeUserPhoto = (req, res, next) => {

        if(!req.file) return next();
        else{
                sharp(req.file.buffer).resize(500,500).toFormat('jpeg').jpeg({quality:80}).toFile(/public/img/users);

        }

         req.file.fileName;
}
--We used sharp package to help users resize the photos and later upload it to the DB.
--Basically uploaded the photos through postman and resized it thru buffer thru sharp package.

LECTURE  NUMBER 203
--Now we are handling the file uplods not through the form submission, but via an API.
--We need to make a formData object now. 
--const form = new formData();
--form.append('name', document.querySelector('name').value);
--form.append('email', document.querySelector('email').value);
--  updateSettings(form, "data");
--form.append('photo', document.getElementById('photo').files[0]);
--console.log(form);



LECTURE NUMBER 204
--We are now gonna upload multiple files now for tours details page.
--Jonas copies multer code from: userController.js.
--It's the same multer configuration.
--const upload =  multer({storage, filter});
--exports.uploadTourImages = upload(Array of Objects);
--[{name: 'imageCover', maxCount: 1}, {name: 'images', maxCount: 3}, {file3}] and so on and so forth. 
--upload.array: When there are mix of fields. . 
--upload.single: When there is a single field with the name.
--upload.fields: When there is a mix of them. Passed as a middleware.
--Now We are configuring the multer. 
--Now Jonas Adds up 2 of middleware functions for configuring the tour images and resizing the tour images.



LECTURE NUMBER 205
--We are preparing request.
--await sharp operations returns a promise and thus can be awaited. next();
--If(!req.file) return next();
--We handled the file uploads with different fields.
--We handled the file uploads successfully. 
--We read files from the multipart file uplods and then saved it to the database, then imageCover and 3 set of images were uploaded there.



LECTURE NUMBER 206
--We are now preparing a complex email handler.
--We are gonna build up a more complex email handler with pug templates and send emails through sendgrid.
--Render html based on pug template.
--const html = pug.renderFile('directory Name');
--We installed html-2-text package in our text editor. ()
--

LECTURE NUMBER 207
--We sent an email on signup of a user account.


LECTURE NUMBER 208
--We will send email on password reset now.


LECTURE NUMBER 209
--Sent Development password reset emails to mailtrap. 
--Sending real emails to real users using sendgrid.


LECTURE NUMBER 210
--We will use payments and book user bookings here.




LECTURE NUMBER 211
--Jonas made a checkoutSession/:tourId route and in controller made a fn called getCheckoutSession.
--Steps involved:
        a- Get the currently booked tour.
                -  const tour = tour.findById(req.params.tourId);
                - Install Stripe npm package.
                - Go to stripe dashboard & copy test publishable and secret key. stripe07 recommended.
                - 


        b-Create Checkout session.
                in bookings controller:
                   - Requiring a stripe will expose us a Fn.   and on passing secret key gives us stripe object that comes up with different methods.
                   - const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);
                   - stripe.checkout.sessions.create({

                        payment_method_types: [card];
                        success_url: `${req.protocol}://${req.get('host')}/`,
                        cancel_url: `url to redirect user when there's cancellation to payment`,
                        customer_email: req.user.email,
                        client_reference_id: req.params.tourId,
                        line_items: [{name: `${tour.name} Tour`}],
                        description: tour.summary,
                        images: [linkOfImage1, linkOfImage2. . .and so on];
                        amount: tour.price*100,
                        currency: 'usd',
                        quality: 1,


                   });
                   -
        c-Send it to the client.

        we await for session to be created by stripe's server and  send the session returned to clients.

Jonas uses johannn to log him in. He then debugs code writeen.
He creates the session and logs it in console for jonas. This would create a payment request in stripe's page.



LECTURE NUMBER 212:
--In this one, we are gonna learn to process stripe payment in frontend, whenever user clicks on a button.
--We show button: Book tour now whenever there is a logged in user.
--Jonas puts in the data-tour-id in the tours to create a session on the server for tourId.
--For the client side, we will append a script for stripe: js.stripe.com/v3/
--In the file, we then will write: const stripe = Stripe(public_Key);
--In the frontend, we will do: const stripe = Stripe('pk_test_BuD0WhateverWhatever'); in a frontend.
--In the frontend itself, he does:  export const bookTour = tourId => {
                                                        
                                                        --Get checkout session from API.

                                                        --const session = await axios('/checkout-session/${tourId}') //Just url for get requests.

                                                        --console.log(session);

                                                        --Create a checkout form + charge credit card for us. 

                                                                      };
--In the frontend, jonas calls stripe global variable and then gets a session via await axios('/checkout-session/tourId') and logs his/her session.
--The stripe page is opened up, and user makes a payment there, when the payment is successful, stripe sends back the response of success to failture to the server, 
also it will redirect the user to the designated page. 
--



LECTURE NUMBER 213
--Now we are gonna create a bookings page as bookingModel.js.
--const bookingSchema = new mongoose.schema({tour:{}, type: ,ref: });


LECTURE NUMBER 214
--Let's now create a  booking document, whenever a user will successfully purchase a tour.
--const {tour, user, price} = req.query;
-- if(!tour && !user && !price) return next();
--await Booking.create({tour, user, price});
--res.redirect(req.originalUrl.split('?)[0]);
--So basically we aren't subscribing the stripe's post requests. But rather using our own API to validate the user's purchase.
--It will be unsecure as it does not incoorporate any safety protocols to validate the users' purchases.

LECTURE NUMBER 215
--Now we're gonna make nice looking booking redirect page. 
--We're gonna make a 'my-tours' page.   
--First find all the bookings that user has made.
--First find all the Bookings through userId.
--Then fetch all the tours through tour's object Id  form doc fetched while fetching booking document with userId.
--const bookings = await Boooking.find(user: userId);
--then loop to all the tours and get them that the user has booked. Next up: we will show list of tours user have booked already.


LECTURE NUMBER 217
--Task: Implement all the related CRUD features in the bookings page.
--




LECTURE NUMBER 217
--Multer is to be imported firstly; const multer = require('multer');
--Like express, call the multer function() and: set the destination to public. dest: public/image/users.
--We can configure multer in a more complex way;
--without dest option, data will be saved into memory.
--In this portion, we are only setting the destination.
--Upload object contains a middleware called upload.single or upload.multiple to handle the multiple or single uploads.



LECTURE NUMBER: 225
--Go to developer tab and then: choose the endpoint url.
--https://www.natours-jonas-herokuapp.com/webhook-checkout.
--Then we should choose the event .checkout event
--Add email and password now.
--Now we will create a checkout event  which triggers automatically when transaction is successful.
--Then we will create a route called bookingCheckout, 
--We now make a try catch block and construct event as below.
--Extract out signature from: req.headers['stripe-signature'];
--Const event = stripe.webhooks.constructEvent(req.body, signature, proces.env.STRIPE_WEBHOOK-SECRET); 
--If there's an error send error to stripe.
--If not, check the type of event, if it is: checkout.event.complete, then it is the event that we would desire.
--If a event is legitimate, then we wanna create an event in the DB.
--We now create a function with a session data, which lies inside of newly constructed event on checking; 
        If event type is: event.type==='checkout.session.complete' then we run a function: createBookingCheckout(event.data.object);
--res.status(200).json({received:true});
--Now create a Booking: const createBookingCheckout is: tour = session.client_reference_id;
--find user now with email session.customer_email.
--Set price.
--await  Booking.create({tour, user, price});
--Push to github and heroku master. *Push Files to Heroku too.
--


                                        COMPLTED 42 HRS

                                      