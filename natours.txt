1-    Users -----------------------> Reviews: (Parent Referencing. 1 to many Relationship between Users and Reviews.)
        1 to many relationship in between them.




2-    Tours ---------------------> Reviews: (Parent Referencing). 



3-    Tours <--------------------> Locations: Few to Few Relationship (A Version of Many to Many Relationship).
                                    Location inside tours and tours inside locatins. . . 



4-    Tours <---------------------> Users: (It is a few to few relationship.)
                                    Because: 1 tours can have few Tour Guides.
                                    1 Guide can be guiding few tours. (Reference or Embed can be used this case using mongoose.)



5-   Tours ------------------------> Bookings: 1 tour can have many bookings.



6-   Users ------------------------> Bookings: 1 user can have many bookings.




Lecture 150:

--GeoSpatial Data is what mongo db supports out of the box.
--It is supported by MongoDB out of the box.
--Location will be written in the tour model.
--We, in GeoJSON, first will write longitudes and later latitudes. [Number: Longitude, Number: Latitude];
--Start location is just an object now, but to create a document out inside a doc, it needs to be an array.
--Now the Jonas will delete the dev datas, and then import the latest data.

LECTURE: 151
--we are gonna embed user document into the tour document.
--When creating the tour document, the user will simply put the array of user ids.
--



 LECTURE: 152:
-- Now that we knew the drawbacks of embeeding, now we will reference the tour
 guides into the tour documents.
--THE MAIN CONCERN: Tours and Users will remain as completely separate entities in our DBs.
--We are gonna learn about REFERENCING in MONGOOSE actually. 
--We are gonna now make it as type:guides:[type: mongoose.Schema.ObjectId];
--We are gonna make it as an array now (to treat it as a subdoc.);
--Now we will place user object id inside of an array.
-- like: ["fadsfadsf", "423sgfafdgad"];
--(Not done: Jonas making the array of uses and posting tours with references
        users and watching it in the compass).

LECTURE: 153:
--              populating the users.
--Since in tours, we wanted to populate Users, we  make a reference to it and then:
query.populate("users");
--watched upto (3:14 mins.)
--Now Jonas wanna push the query.populate("fieldName") thing into a query middleware.
--Because every single time otherwise we shall have to write .populate("field"),
        and also -_V and -_passwordChanged at to not show minus fields if we're only using populates.

        and also update everything in all routes for this effect to reflect
        everywhere.
        --SO HE JUS THAS SETUP --QUERY MIDDLEWARES -- THAT'S ABOUT IT. 


LECTURE NUMBER: 154

//We want a review, rating and created at, and we would also want a reference to the tour that this review belongs 
to and also the user who wrote this review.  Basucally 2 parent references in here.
--we made a reviewSchema and then we linked our reviews with user and tour. Then we used virtuals: true and 
        tovirtuals: true and we also formed some of key value pairs inside of the reviewModel.

LECTURE NUMBER: 155
--We created the review contreoller, and  wrote a review by signing up and logging in one user and using 
his _id with tour's _id. Now we will populate in lecture: 156.

LECTURE NUMBER: 156
--This time we are gonna populate reviews both by tour data and the user data. 
--We will chain populate method twice.
--2 populates will query db twice.
--took 23 mss my case for 2 db operations.
--Completed the population
--BUG (series of inclusions and exclusion error for --durationWeeks-- for some reason.);

LECTURE NUMBERE 157
--There is a detailed explaination in the video itself, on what needs to be done you know.
--There is a convention for virtual populate now.
--Without  actually persisting it into the DB, we store the array of IDs of reviews in tours collection.

LECTURE NUMBER 158
--In the real world, the user id should come from the currently logged in user.
--We would wanna make a request for the post, reviews,
--we will follow the pattern for: /tour/tourObjectId123/reviews/reviewsObjectId (POST/GET REQUESTS).
--we are now gonna implement the nested route as shown as above.
--we will now implement it right away starting from the tour routes.
-- 

LECTURE NUMBER 159
--In here now we are gonna implement the nested routes in express.
--In 158, what we did is we created a route the way: (POST): tours/tourId/reviews.
--Here we gave tourId in params, used the tourId and then imported the reviewController in tourRouter.
--We then created a review out of tourId and UserId.
--Basically in tour router, we had to import the review controller.
--Now one thing to remember, we can create reviews in 2 ways: Being on Review Router, or by being on tour router.
--We will have duplicate codes, if in case we wanna change anything.
--We are now gonna learn about MERGE PARAMS in Express.
--For the separation of concerns, we will now remove the piece of code that creates reviews from the 
 tourRouter.
--So this way --> import statement of reviewController <-- too is unnecessary.
--Now Jonas Imports the reviewRouter inside of the tourRouter to connect between 2 routers (not controllers.)
--BASICALLY FIRST EVER USE OF (ROUTER.USE('/:tourId/reviews', reviewRouter));
--Since now we are redirected to the reviewRouter, reviewRouter will nowhere know about the tourId when referred.
--We will now incoorporate mergeParams.
--We will now in --reviewRouter do: const router = express.Router({mergeParams: true});

                WhAt DiD nOt WoRk TiLl NoW:
a) Reviews: -> always [] after successfully creating reviwes.

LECTURE NUMBER 160
--ADDING A NESTED GET ENDPOINT --
--
