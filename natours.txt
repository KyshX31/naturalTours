//***********************************************************************************//
//**********************************************************************************//
1-    Users -----------------------> Reviews: (Parent Referencing. 1 to many Relationship between Users and Reviews.)
        1 to many relationship in between them.




2-    Tours ---------------------> Reviews: (Parent Referencing). 



3-    Tours <--------------------> Locations: Few to Few Relationship (A Version of Many to Many Relationship).
                                    Location inside tours and tours inside locatins. . . 



4-    Tours <---------------------> Users: (It is a few to few relationship.)
                                    Because: 1 tours can have few Tour Guides.
                                    1 Guide can be guiding few tours. (Reference or Embed can be used this case using mongoose.)



5-   Tours ------------------------> Bookings: 1 tour can have many bookings.



6-   Users ------------------------> Bookings: 1 user can have many bookings.




Lecture 150:

--GeoSpatial Data is what mongo db supports out of the box.
--It is supported by MongoDB out of the box.
--Location will be written in the tour model.
--We, in GeoJSON, first will write longitudes and later latitudes. [Number: Longitude, Number: Latitude];
--Start location is just an object now, but to create a document out inside a doc, it needs to be an array.
--Now the Jonas will delete the dev datas, and then import the latest data.

LECTURE: 151
--we are gonna embed user document into the tour document.
--When creating the tour document, the user will simply put the array of user ids.
--



 LECTURE: 152:
-- Now that we knew the drawbacks of embeeding, now we will reference the tour
 guides into the tour documents.
--THE MAIN CONCERN: Tours and Users will remain as completely separate entities in our DBs.
--We are gonna learn about REFERENCING in MONGOOSE actually. 
--We are gonna now make it as type:guides:[type: mongoose.Schema.ObjectId];
--We are gonna make it as an array now (to treat it as a subdoc.);
--Now we will place user object id inside of an array.
-- like: ["fadsfadsf", "423sgfafdgad"];
--(Not done: Jonas making the array of uses and posting tours with references
        users and watching it in the compass).

LECTURE: 153:
--              populating the users.
--Since in tours, we wanted to populate Users, we  make a reference to it and then:
query.populate("users");
--watched upto (3:14 mins.)
--Now Jonas wanna push the query.populate("fieldName") thing into a query middleware.
--Because every single time otherwise we shall have to write .populate("field"),
        and also -_V and -_passwordChanged at to not show minus fields if we're only using populates.

        and also update everything in all routes for this effect to reflect
        everywhere.
        --SO HE JUS THAS SETUP --QUERY MIDDLEWARES -- THAT'S ABOUT IT. 


LECTURE NUMBER: 154

//We want a review, rating and created at, and we would also want a reference to the tour that this review belongs 
to and also the user who wrote this review.  Basucally 2 parent references in here.
--we made a reviewSchema and then we linked our reviews with user and tour. Then we used virtuals: true and 
        tovirtuals: true and we also formed some of key value pairs inside of the reviewModel.

LECTURE NUMBER: 155
--We created the review contreoller, and  wrote a review by signing up and logging in one user and using 
his _id with tour's _id. Now we will populate in lecture: 156.

LECTURE NUMBER: 156
--This time we are gonna populate reviews both by tour data and the user data. 
--We will chain populate method twice.
--2 populates will query db twice.
--took 23 mss my case for 2 db operations.
--Completed the population
--BUG (series of inclusions and exclusion error for --durationWeeks-- for some reason.);

LECTURE NUMBERE 157
--There is a detailed explaination in the video itself, on what needs to be done you know.
--There is a convention for virtual populate now.
--Without  actually persisting it into the DB, we store the array of IDs of reviews in tours collection.

LECTURE NUMBER 158
--In the real world, the user id should come from the currently logged in user.
--We would wanna make a request for the post, reviews,
--we will follow the pattern for: /tour/tourObjectId123/reviews/reviewsObjectId (POST/GET REQUESTS).
--we are now gonna implement the nested route as shown as above.
--we will now implement it right away starting from the tour routes.
-- 

LECTURE NUMBER 159
--In here now we are gonna implement the nested routes in express.
--In 158, what we did is we created a route the way: (POST): tours/tourId/reviews.
--Here we gave tourId in params, used the tourId and then imported the reviewController in tourRouter.
--We then created a review out of tourId and UserId.
--Basically in tour router, we had to import the review controller.
--Now one thing to remember, we can create reviews in 2 ways: Being on Review Router, or by being on tour router.
--We will have duplicate codes, if in case we wanna change anything.
--We are now gonna learn about MERGE PARAMS in Express.
--For the separation of concerns, we will now remove the piece of code that creates reviews from the 
 tourRouter.
--So this way --> import statement of reviewController <-- too is unnecessary.
--Now Jonas Imports the reviewRouter inside of the tourRouter to connect between 2 routers (not controllers.)
--BASICALLY FIRST EVER USE OF (ROUTER.USE('/:tourId/reviews', reviewRouter));
--Since now we are redirected to the reviewRouter, reviewRouter will nowhere know about the tourId when referred.
--We will now incoorporate mergeParams.
--We will now in --reviewRouter do: const router = express.Router({mergeParams: true});

                WhAt DiD nOt WoRk TiLl NoW:
a) Reviews: -> always [] after successfully creating reviwes. (skipped as it took lots of time, will come back later.)

LECTURE NUMBER 160
--ADDING A NESTED GET ENDPOINT --
--ADDED

LECTURE NUMBER 161
--we added up some factory functions for delete. . . 
--past 3 mins left to watch.
--Delets a user too (of course)

LECTURE NUMBER 162
--Creating a factory function for -updating- and -deleting-
--Update: The patch functionality have been embedded in all the controllers, -review, tour and user controller.
-- Implemented Update:
--Implementing Create Handler (testing left):
--slightly confused on implementation for creation of reviews as reviews are created in tour via user.
--In creation for reviews, jonas makes up a new middleware function and he will inject
  that middleware function into the reviewrouter, that will possibly remove the hurdle of checking up of
  the req.body.user and req.body.tourId are either non existent, if not existent for sure
  then, that middleware fn would set it in the body for creation of reviews.
--Required checking the valid Object IDs and all in my case.
--checking in postman is left. (***********POSTMAN THINGS ARE STILL LEFT TO BE DONE ***********)
--

LECTURE NUMBER 163
--Implementing the getOne router handler.
--Instead for us for having just getting a data, we sometimes have a populate options.
--const doc  = await Model.findById(req.params.id).populate('reviews');
--All completed for get One


LECTURE NUMBER 164
--adding a /me endpoiont.
--for a /me endpoint, we will need: we will need to watch a id from the req.user;
--Here we will fake it as if id is coming in request params. 
--Other implementation would be similar to getting a user.
--Here what we did was we injected a middleware before the /specificUserId 
  middleware. And if a user visits /me then, we will programatically put the UserId
  in the params of the logged in user. and boom. It works.

LECTURE NUMBER 165
--Here we will add up the missing authorisation and authentication for any user.
--It is done in Router Basically.
--Jonas Protects some of routes using ROuter.use() method of express.
--Configures RBACs on some of routes on 3 different resources.
--Chapter ends here.

LECTURE NUMBER 166
--We basically imported some of resources into our DB from the file system.
--Imported tours, reviews and users resources.

LECTURE NUMBER 167
--We are now improving the read preformances of the Database with indexes.
--Will do create some Indexes later.
--(❌❌)

LECTURE NUMBER 168
--Removing the constant queries of the related data sets.
--When a review will be created, we will find the way to update tour.
--We will be able to show up number of ratings and average of all the ratings.
--We never ever calculated average ratings quite before, Now that we will calculate it when a review is created or deleted.
--Using reviewModel, we create a function in review model, and using the fn, we will calculate the average of the tours there.
-- The function will at the end update the tour document too.
--We will make a  middleware that will keep track of all the documents.
--


LECTURE NUMBER 169
--(findByIdAndUpdate & findByIdAndDelete), Now we are gonna update the reviews upon update and delete.
--Fragments of documentsa are obtained by Find+Update or Find+Delete methods, so we won't be able to run the 
  ReviewCalculation method as above.
-- Testing is left for this one - whether our implementation of handling the ratingsAverage
   would work or not. (❌❌)
--(Did not work on update and delete.);
--Need to rethink again.

LECTURE NUMBER 170
--We are gonna use a simple trick to  let users not write more than one review for each tour.
--Each User can review one tour and that too only once.
--Since the new objectId made by combination of user and posts have been made unique.
--(❌❌)

LECTURE NUMBER 171
--We are gonna learn about geospatial queries.
--Helps users search for tours in a specific points.
--Distance would be of any miles say 250 mi.
--I can being in Nepal, search for tours based within Nepal.
--used some of geospatial queries now.
--will use somewhere or sometime.
--used $geoWithin and $centerSphere mongo operators now.
--discovered Bunch others in their site.

LECTURE NUMBER 172
--Here we will discover about the distances between start location and the point where tour is located.
--We will use a $geoNear aggregation.
--This requires one of the key to be indexed for using geoNear.
--We index: startlocation:'2dSphere'. It is mandatory.
--Implemented totally.



LECTURE NUMBER 173
--Creating the API Documentation for our APIs.
--We will now manage the passwords in a variables. (--More to watch later--).
--More to be done later.

//*********************SERVER SIDE RENDERING ********************************//
//**************************************************************************//

LECTURE NUMBER 175
--We are now gonna implement the server side rendering in our project.
--We can now log in and sign up in here.
--We can see all the reviews of the users and we can also open up the personal user account.
--We can also check all the bookings of the user.
--We will implement the maps into our project too.


LECTURE NUMBER 176
--This deals about setting up the pug templates and working with it.
--We can easily fill out the template and fill up the data using pug.
--There are couple of other templating engines too available like handlebars or ejs.
--Pugs are also called Views in Express because they are views in MVC Architecture.
--Now we will create up a views folder.
--Now we set view engiene to -pug and so on and so forth.
--We now have created everything for our pug things.
--Now inside pug, we are gonna create -base.pug & then check if it will work. . . 
--

LECTURE NUMBER 177
--Now we are gonna implement a pug in our code.
--The variables that we will pass inside the pug's data as: .render('base', {key:value //This is called locals});
--To show locals we follow the syntax: p1= key; value of the key will be rendered automatically.
--Each assest confirms it's own HTTP request.
--so in favicon, there's img/favicon.png, so how does it work?
--It works by It's own GET request being fired.
--Now we're gonna see how we can send data to the pug templates.
--We can create comments now. . . And the thing is that we can create 2 kinds of comments. 
-- We can embed JS in our code:   Eg: h2= message.toUpperCase();
--Unbuffered code are code that's not gonna add anything to the output.
        
        Eg: -const x = 9;
             h2 = 2 * x;

             p This is just some text.
--We did some computations. We will now convert our Starter HTML file into pug template.



LECTURE NUMBER 178
-- Including the file i.e one template to an another template now.
--done

LECTURE NUMBER 179
--This was all about including the files into the main pug file.
--Syntax: include pugFileName.pug

LECTURE NUMBER 180:
--This lecture is all about using -extends-. Using which we can use the same base layout for all the pages.
--We can extend one pug to an another Can be applied to every single page we can render.
--we made a overview page render route.
--We would also want a route to /tour, so we made it.
--Base template is the parent template and this process is also called extending.
--Now in the overview page, it will extend the base template.
--Understood the differences betweeen extends and includes.
--The base template if is extended on the child template, then parent bases' 


LECTURE NUMBER 181
--Just with the resources, we are gonna create controller for the views.
--181 has come to an end with me building some routes for our views.

LECTURE NUMBER 182
--Now we're building the tours overview page.
--we made upto showing up 9 tours but data shown are not dymamic even now. (NOT DONE IN THE PRACTICE)

LECTURE NUMBER 183
--Here now we are going to basically fill the actual cards with the actual data.
--if in tours we are getting data then we will loop tours and for every tour, we show tour's properties in each cards.
--Jonas now fills up different data into the tour template.
--The example includes: Tour length, tour summary, tour description and all that.
--Now goes start dates. We do: tours.startDaates
--Now we will add relative URLs.
--We added a '|' or 'pipeline' to make it such tha we will get an empty space like as of using <br>
--W


LECTURE  NUMBER 184 
--We are gonna build up a TOUR DETAIL Page.
--We are just gonna leave the map for next lecture. But for now we will work upto Showing up reviews.
--For showing indivudual tours, we shall need to show reviews + tour guides +  
--Render templates using the data from step 01 again.
--We will search the tours with the help of slug. . 
--We should:
        1- Find the dedicated tour.
        2-Populate the tour data with Reviews.
        3-Respond the user with necessary template.

--We have already made the PUG template already.
--Jonas also made the Indivudual tour overview page.
--Now we will get some visually appealing website.
--Now we are gonna look about next pug fetature called: PUG MIXINS.
--For this, we will have to make a preprocessor box.
--We write mixin for this reason, and then write the name of the mixin.
--Jonas makes a preprocessor like PUG MIXIN where he can pass in: 1-Label, 2-Text, and 3-Icon.
--Usage:
        +mixinName(...args);
        Mixin is like a function.

--Similarly the part 01 of the tour completion portion has now come into an end.

LECTURE NUMBER 185
--Building the Tour Detail Page.
--Now we are looping for all the tour guides data from the DB  and then we are basically showing it in our page.
--We will incoorporate each loop in the array.
--We will use:
        each guides in tour.guides.
--Now we are gonna write a role of the user too.
--Since in DB we saved roles as lead-guide and tour-guide and all, but don't wanna show up "-",
  We shall incoorporate --conditionals-- in pug template.
--We will some Unbuffered code and using vanilla js, remove the "-" from the mid roles.
--Or Do anything similar.
--Now for the description box, In DB, we are saving one paragraph for description, crux is we are using \n to distinguish new lines and show up 
  the new line.
  
--Coming onto reviews now, Jonas populates the review.
--Time to show up  stars now for the ratings we have.
--Applies logic to apply for stars in the reviews field.
--Now We gotta go to the "/" page.
--We can also create a separate file for mixins. Jonas calls it as __reviewCard.pug.
--We will write: __reviewCard.pug and then where we should use it: we do: include __reviewCard.pug.
--We will also change the call to action field now. 
--Jonas will now maintain the --call to action-- Now. And then:  Now the page is completed now.


LECTURE NUMBER 186:
--We are now gonna integrate --mapbox-- in our project.
--The mapbox library now works in the  front end.
--We will write some javascript in the client side, and then: we are gonna integrate it.
--We say -block head.
--Jonas basically extracts out the locations from the server and puts the array of lcoations, converting them into strings into locations variable.
--Now to avail it in JS file, it is done this way: JSON.parse(converted String);


LECTURE NUMBER 187
--Integrating the mapbox now in our project.
--Make an account on the mapbox and then: We are gonna itegrate the mapbox cdn into the page.
--We are gonna incoorporate the append head technique now.
--We are gonna put up the link: using block append head technique.
--In mapbox.js file, We are gonna append the access token there.mapboxgl.accessToken.
--var map = new mapboxgl.Map({
                                container: 'map' /*will put map on the id of map*/,
                                style:'mapbox://styles/mapbox/streets-v11',
                                center:[longitude, latitude] //Focuses the map on this center,
                                zoom:4,
                                interractive:true, //Boolean True or False,
                                scrollZoom:false,
                                clickTolerance: false //Boolean
                             });

--Create a mapbox token now.f
--It loads the default map already.
--Go to design studio in mapbox now.
--Jonas now chooses the light map. Chooses the styles and then clicks on -use-
--Now we are gonna get our access URL and style URL now.
--Put it in the javascript code.
--We can basically now zoom in, zoom out and basically do anything we want.
--We can pin a centered coordinates, but by the way the using bound coordinates would be beneficial for array of coordinates,
        basically we wanna show up map, showing all the available geolocation points.

-- const bounds = new mapboxgl.LngLatBounds     ({
                                                });
--To log locations, we shall need markers.

--                              locations.forEach(loc=>{
                                        document.createElement('div');
                                        el.className = 'marker',
                                        new mapBoxGl.Marker(
                                                {
                                                        element: el,
                                                        anchor: 'bottom', //places the bottom part of the marker into the exact GPS Coordinates.
                                                }
                                        )
                                        }).setLngLat(loc.coordinates).addTo(map);

                                        new mapboxgl.popup({offset:30}).setLngLat(loc.coordinates).setHTML(`<p>Day ${loc.day}: ${loc.description} </p>`).addTo(map);

                                        bounds.extend(loc.coordinates
                                        ); //Pass each of locations into  bounds.extend(indivudualLocation);

--map.fitBounds(bounds,
                                                                          {
                                                                             top:200,
                                                                             bottom:200,
                                                                             left:100,
                                                                             right:100
                                                                           }); //Adds the padding of 50px to show all the pinned points.


LECTURE NUMBER 188
--We are now gonna add up the login screen to make sure that the user can now log in.
--We are now gonna add the '/login' route handler which gives out HTML to us that shows us up the login screen.
--We will do it in the views folder.
--exports.getLoginForm = (req,res)=>{ res.status(200).render('login') };
--call it login.pug
--In login.pug ---> extends base;
--block content
--Let's go onto our login router now. 
--Sign in handler is made.
--Now we are going to prepare the sign up page. (SIGN UP WAS GONNA BE AS LONG AS LOGGING IN.);
--Jonas has made up a CSS file that includes the validation logic for the form.
--
--

LECTURE NUMBER 189
--Using our login API to actually log in the users.
--We will incoorporate the cookie thingy too to the user to check user sessions.
--We will be working on the client side JS code then.
--We created the -login.js- file inside of the public > js > login.JS

--document.querySelector('.form').addEventListener('submit', e =>{
                                                                 e.preventDefault();
                                                                 const email = email-value-from-email-element
                                                                 const password = password-value-from-pswd-element
                                                                 })

--We added the login.js file inside the pug template of the login.
--We showed the password and email in the console. (Just for testing);
--We are going to use axios to make a HTTP requests right from the next lecture.
-- <script src=" https://cdn.jsdelivr.net/npm/axios@1.11.0/dist/axios.min.js "></script>
-- It exposes the  axios object into the global scpope that we can use it.
-- const res = await axios({
                method: 'POST',
                url   : '',
                data: {//json can be sent in here with the help of Axios.}
        })
--Axios triggers an error if server responds any non 2xx (Other than status not starting with 2) status codes to us.
--We made a try and catch block to incoorporate the login handler.
--In case of errors, axios puts error inside ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~errObject.response.data;
--Because the browser will use the cookie, We have to install other package inside of our backend called cookieparser.
--const cookieParser = require('cookie-parser');
--Subscequently, We inject the middleware exposed by cookie-parser globally to all the requests using  express' middleware: app.use('cookieParser');
--app.use((req,res,next)=>{

                        });
--Now we are going to watch the cookies inside of the backend using req.cookies. 
--this logs cookies to us. (as object. . {jwt: jwtData});
--Now Jonas imports the auth controller in the views. 
--And then: authController.procect is injected inside the views routes.
--Jonas deletes the cookies from the front end, and this logs out the user.
--After logging in, we will get our JWT, which we will store again in the req.cookies. . .
  and everytime server gets the JWT, it authenticates the user, then gives or revokes an access to certain routes.
--When the user is logged in, we do not wanna show the login and signup thingy on the top of the screen, so we will basically remove it in the next lecture.
--On coming lectures, we will also incoorporate popups for displaying success or errors.
--

LECTURE NUMBER 190
--This is the part 02 of implementing the login functionality.
--We are going to conditionally render the login and signup block watching if a user is logged in or not.
--We are now going to make a new middleware that sees if a user is logged in or not for like all the routes and show or hide the login/register heading in the navbar.
-isLoggedIn middleware will take care of that.
--It will only check if a JWT Exists and it resolves to a user that exists in DB and user has not changed the password, returns next(); immediately.
--We will use res.locals.user, then inside of a template, there will be a user.
--res.locals.user = currentUser will hold the local variables needed for the user. Then we will call next();

--LOGIC OF THE MIDDLEWARE:
                        a- If No JWT in cookies: return next();
                        b- If Password was changed after JWT was issued,  return next();
                        c- Otherwise, assign res.locals.user  = currentUser and return next();
                        This way if locals is having user object inside of it, then the user is logged in, else user is not logged in.
--By using the Locals, we are determining if we should should show up a login/register or any other screens than that.


LECTURE NUMBER 191

--Let's now finish up the logging functionality by now.
--Jonas creats alerts.js
--Also talks about creating the bundlers like webpack.
--We installed a package called: parcel bundler and wrote the entry js file + output location + output file name in the script in package.json.
--We minified one of JS file we had.
--